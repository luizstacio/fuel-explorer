scalar Address
scalar AssetId
scalar BlockId
scalar Bytes32
scalar ContractId
scalar HexString
scalar MessageId
scalar Salt
scalar Signature
scalar Tai64Timestamp
scalar TransactionId
scalar TxPointer
scalar U64
scalar UtxoId

type Contract {
  id: ContractId!
  bytecode: HexString!
  salt: Salt!
}

union Consensus = Genesis | PoAConsensus

type PoAConsensus {
  # Gets the signature of the block produced by `PoA` consensus.
  signature: Signature!
}

type Genesis {
  # The chain configs define what consensus type to use, what settlement layer to use,
  # rules of block validity, etc.
  chainConfigHash: Bytes32!

  # The Binary Merkle Tree root of all genesis coins.
  coinsRoot: Bytes32!

  # The Binary Merkle Tree root of state, balances, contracts code hash of each contract.
  contractsRoot: Bytes32!

  # The Binary Merkle Tree root of all genesis messages.
  messagesRoot: Bytes32!
}

type Header {
  # Hash of the header
  id: BlockId!

  # The layer 1 height of messages and events to include since the last layer 1 block number.
  daHeight: U64!

  # Number of transactions in this block.
  transactionsCount: U64!

  # Number of output messages in this block.
  outputMessagesCount: U64!

  # Merkle root of transactions.
  transactionsRoot: Bytes32!

  # Merkle root of messages in this block.
  outputMessagesRoot: Bytes32!

  # Fuel block height.
  height: U64!

  # Merkle root of all previous block header hashes.
  prevRoot: Bytes32!

  # The block producer time.
  time: Tai64Timestamp!

  # Hash of the application header.
  applicationHash: Bytes32!
}

type Block {
  id: BlockId!
  header: Header!
  consensus: Consensus!
  transactions: [Transaction!]!
}

##########################################################
## Transaction
##########################################################

type Transaction {
  id: TransactionId!
  inputAssetIds: [AssetId!]
  inputContracts: [Contract!]
  gasPrice: U64
  gasLimit: U64
  maturity: U64
  txPointer: TxPointer
  isScript: Boolean!
  isCreate: Boolean!
  isMint: Boolean!
  inputs: [Input!]
  outputs: [Output!]!
  witnesses: [HexString!]
  receiptsRoot: Bytes32
  status: TransactionStatus
  receipts: [Receipt!]
  script: HexString
  scriptData: HexString
  bytecodeWitnessIndex: Int
  bytecodeLength: U64
  salt: Salt
  storageSlots: [HexString!]

  # Return the transaction bytes using canonical encoding
  rawPayload: HexString!
}

##########################################################
## Transaction =>> Metadata
##########################################################

enum ReturnType {
  RETURN
  RETURN_DATA
  REVERT
}

type ProgramState {
  returnType: ReturnType!
  data: HexString!
}

type SqueezedOutStatus {
  reason: String!
}

type SubmittedStatus {
  time: Tai64Timestamp!
}

type FailureStatus {
  block: Block!
  time: Tai64Timestamp!
  reason: String!
  programState: ProgramState
}

type SuccessStatus {
  block: Block!
  time: Tai64Timestamp!
  programState: ProgramState
}

input TimeParameters {
  # The time to set on the first block
  startTime: U64!

  # The time interval between subsequent blocks
  blockTimeInterval: U64!
}

union TransactionStatus =
    SubmittedStatus
  | SuccessStatus
  | SqueezedOutStatus
  | FailureStatus

##########################################################
## Transaction =>> Outputs
##########################################################

type MessageOutput {
  recipient: Address!
  amount: U64!
}

type ChangeOutput {
  to: Address!
  amount: U64!
  assetId: AssetId!
}

type CoinOutput {
  to: Address!
  amount: U64!
  assetId: AssetId!
}

type ContractCreated {
  contract: Contract!
  stateRoot: Bytes32!
}

type ContractOutput {
  inputIndex: Int!
  balanceRoot: Bytes32!
  stateRoot: Bytes32!
}

type VariableOutput {
  to: Address!
  amount: U64!
  assetId: AssetId!
}

union Output =
    CoinOutput
  | ContractOutput
  | MessageOutput
  | ChangeOutput
  | VariableOutput
  | ContractCreated

##########################################################
## Transaction =>> Inputs
##########################################################

union Input = InputCoin | InputContract | InputMessage

type InputCoin {
  utxoId: UtxoId!
  owner: Address!
  amount: U64!
  assetId: AssetId!
  txPointer: TxPointer!
  witnessIndex: Int!
  maturity: U64!
  predicate: HexString!
  predicateData: HexString!
}

type InputContract {
  utxoId: UtxoId!
  balanceRoot: Bytes32!
  stateRoot: Bytes32!
  txPointer: TxPointer!
  contract: Contract!
}

type InputMessage {
  messageId: MessageId!
  sender: Address!
  recipient: Address!
  amount: U64!
  nonce: U64!
  witnessIndex: Int!
  data: HexString!
  predicate: HexString!
  predicateData: HexString!
}


##########################################################
## Transaction =>> Receipts
##########################################################

type Receipt {
  contract: Contract
  pc: U64
  is: U64
  to: Contract
  toAddress: Address
  amount: U64
  assetId: AssetId
  gas: U64
  param1: U64
  param2: U64
  val: U64
  ptr: U64
  digest: Bytes32
  reason: U64
  ra: U64
  rb: U64
  rc: U64
  rd: U64
  len: U64
  receiptType: ReceiptType!
  rawPayload: HexString!
  result: U64
  gasUsed: U64
  data: HexString
  messageId: MessageId
  sender: Address
  recipient: Address
  nonce: Bytes32
  contractId: ContractId
}

enum ReceiptType {
  CALL
  RETURN
  RETURN_DATA
  PANIC
  REVERT
  LOG
  LOG_DATA
  TRANSFER
  TRANSFER_OUT
  SCRIPT_RESULT
  MESSAGE_OUT
}

##########################################################
## Query
##########################################################

type Query {
  transactions(
    first: Int
    after: String
    last: Int
    before: String
  ): PageResult<Transaction!> @query(table: "Transaction", paginate: true)

  blocks(
    first: Int
    after: String
    last: Int
    before: String
  ): PageResult<Block!> @query(table: "Block", paginate: true)
}
